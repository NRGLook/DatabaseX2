CREATE TABLE students (
                          id NUMBER PRIMARY KEY,
                          name VARCHAR2(100),
                          group_id NUMBER,
                          CONSTRAINT fk_group_id FOREIGN KEY (group_id) REFERENCES groups(id)
);

CREATE TABLE groups (
                        id NUMBER PRIMARY KEY,
                        name VARCHAR2(100),
                        c_val NUMBER
);


CREATE SEQUENCE students_seq START WITH 1;

CREATE OR REPLACE TRIGGER trigger_students_auto_increment_id
    BEFORE INSERT ON students
    FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT students_seq.nextval INTO :new.id
FROM dual;
END;

CREATE TABLE students_log (
                              id NUMBER GENERATED BY DEFAULT AS IDENTITY,
                              username VARCHAR2(100) NOT NULL,
                              date_of_action DATE NOT NULL,
                              operation VARCHAR2(10) NOT NULL,
                              stud_id NUMBER NOT NULL,
                              stud_name VARCHAR2(100) NOT NULL,
                              stud_group_id NUMBER NOT NULL
);



CREATE OR REPLACE TRIGGER trigger_students_unique_id
    BEFORE INSERT ON students
    FOR EACH ROW
DECLARE
v_count INT;
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT COUNT(*) INTO v_count
FROM students
WHERE id = :new.id;

IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ID must be unique');
END IF;
END;
/

CREATE OR REPLACE TRIGGER trigger_groups_unique_name
    BEFORE INSERT ON groups
    FOR EACH ROW
DECLARE
v_count INT;
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT COUNT(*) INTO v_count
FROM groups
WHERE groups.name = :new.name;

IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Group name must be unique');
END IF;
END;
/

CREATE OR REPLACE TRIGGER trigger_delete_group_fk
    AFTER DELETE ON groups
    FOR EACH ROW
BEGIN
DELETE FROM students WHERE group_id = :old.id;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in trigger_delete_group_fk: ' || SQLERRM);
END;
/

CREATE OR REPLACE TRIGGER trigger_insert_student_fk
    BEFORE INSERT ON students
    FOR EACH ROW
DECLARE
v_count INT;
BEGIN
SELECT COUNT(*) INTO v_count
FROM groups
WHERE groups.id = :new.group_id;

IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20000, 'Group ID does not exist');
END IF;
END;
/

CREATE OR REPLACE TRIGGER trigger_students_logging
    AFTER INSERT OR UPDATE OR DELETE ON students
    FOR EACH ROW
DECLARE
v_username VARCHAR2(30) := USER;
    v_date DATE := SYSDATE;
    v_operation VARCHAR2(20);
BEGIN
    IF INSERTING THEN
        v_operation := 'INSERT';
INSERT INTO students_log (username, date_of_action, operation, stud_id, stud_name, stud_group_id)
VALUES (v_username, v_date, v_operation, :new.id, :new.name, :new.group_id);
ELSIF UPDATING THEN
        v_operation := 'UPDATE';
INSERT INTO students_log (username, date_of_action, operation, stud_id, stud_name, stud_group_id)
VALUES (v_username, v_date, v_operation, :new.id, :new.name, :new.group_id);
ELSIF DELETING THEN
        v_operation := 'DELETE';
INSERT INTO students_log (username, date_of_action, operation, stud_id, stud_name, stud_group_id)
VALUES (v_username, v_date, v_operation, :old.id, :old.name, :old.group_id);
END IF;
END;
/

CREATE OR REPLACE PROCEDURE restore_students_info_by_date (date_time IN TIMESTAMP)
AS
    cur_date DATE := SYSDATE;
BEGIN
DELETE FROM students;

FOR student IN (SELECT * FROM students_log WHERE date_of_action <= date_time ORDER BY date_of_action ASC) LOOP
            IF student.operation = 'INSERT' THEN
                INSERT INTO students (id, name, group_id) VALUES (student.stud_id, student.stud_name, student.stud_group_id);
            ELSIF student.operation = 'UPDATE' THEN
UPDATE students SET group_id = student.stud_group_id, name = student.stud_name WHERE student.stud_name = name;
ELSIF student.operation = 'DELETE' THEN
DELETE FROM students WHERE student.stud_name = name;
END IF;
END LOOP;

DELETE FROM students_log WHERE DATE_OF_ACTION >= cur_date;
END;


CREATE OR REPLACE TRIGGER trigger_group_c_val_students_update
    AFTER UPDATE ON students
                     FOR EACH ROW
BEGIN
    IF (:old.group_id != :new.group_id) THEN
UPDATE groups SET c_val = c_val - 1 WHERE id = :old.group_id;
UPDATE groups SET c_val = c_val + 1 WHERE id = :new.group_id;
END IF;
END;
/

CREATE OR REPLACE TRIGGER trigger_group_c_val_students_insert
    AFTER INSERT ON students
    FOR EACH ROW
BEGIN
UPDATE groups SET c_val = c_val + 1 WHERE id = :new.group_id;
END;
/

CREATE OR REPLACE TRIGGER trigger_group_c_val_students_delete
    BEFORE DELETE ON students
    FOR EACH ROW
BEGIN
UPDATE groups SET c_val = c_val - 1 WHERE id = :old.group_id;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in trigger_group_c_val_students_delete: ' || SQLERRM);
END;
/

DELETE FROM students;
DELETE FROM groups;
DELETE FROM students_log;
COMMIT;

INSERT INTO groups (id, name, c_val) VALUES (1, '153501', 0);
INSERT INTO groups (id, name, c_val) VALUES (2, '153502', 0);
INSERT INTO groups (id, name, c_val) VALUES (3, '153503', 0);
INSERT INTO groups (id, name, c_val) VALUES (4, '153504', 0);
COMMIT;

INSERT INTO students (id, name, group_id) VALUES (1, 'Ilya', 4);
INSERT INTO students (id, name, group_id) VALUES (2, 'Pavel', 1);
INSERT INTO students (id, name, group_id) VALUES (3, 'Dasha', 2);
INSERT INTO students (id, name, group_id) VALUES (4, 'Eugene', 3);
INSERT INTO students (id, name, group_id) VALUES (5, 'Kolya', 4);
COMMIT;

SELECT * FROM students;
SELECT * FROM groups;
SELECT * FROM students_log;

CALL restore_students_info_by_date(TO_TIMESTAMP('2024-02-09 20:00:00', '2024-02-21 15:11:00'));

INSERT INTO groups VALUES (5, '153505', 0);

DELETE FROM groups WHERE id = 2;

DELETE FROM students WHERE name LIKE '%PP%';

INSERT INTO groups VALUES (8, '153502', 0);
INSERT INTO groups VALUES (9, '153502', 0);

INSERT INTO students (id, name, group_id) VALUES (6, 'PAUL', 1);