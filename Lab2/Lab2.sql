--LAB2
--1
CREATE TABLE students (
                          id NUMBER PRIMARY KEY,
                          name VARCHAR2(100),
                          group_id NUMBER,
                          CONSTRAINT fk_group_id FOREIGN KEY (group_id) REFERENCES groups(id)
);

CREATE TABLE groups (
                        id NUMBER PRIMARY KEY,
                        name VARCHAR2(100),
                        c_val NUMBER
);


CREATE SEQUENCE students_seq START WITH 1;

CREATE OR REPLACE TRIGGER trigger_students_auto_increment_id
    BEFORE INSERT ON students
    FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT students_seq.nextval INTO :new.id
FROM dual;
END;

CREATE SEQUENCE groups_seq START WITH 1;

CREATE OR REPLACE TRIGGER trigger_groups_auto_increment_id
    BEFORE INSERT ON groups
    FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT groups_seq.nextval INTO :new.id
FROM dual;
END;

CREATE TABLE students_log (
                              id NUMBER GENERATED BY DEFAULT AS IDENTITY,
                              username VARCHAR2(100) NOT NULL,
                              date_of_action DATE NOT NULL,
                              operation VARCHAR2(10) NOT NULL,
                              stud_id NUMBER NOT NULL,
                              stud_name VARCHAR2(100) NOT NULL,
                              stud_group_id NUMBER NOT NULL
);


--2
CREATE OR REPLACE TRIGGER trigger_students_unique_id
    BEFORE INSERT ON students
    FOR EACH ROW
DECLARE
v_count INT;
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT COUNT(*) INTO v_count
FROM students
WHERE id = :new.id;

IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'ID must be unique');
END IF;
END;
/

CREATE OR REPLACE TRIGGER trigger_groups_unique_name
    BEFORE INSERT ON groups
    FOR EACH ROW
DECLARE
v_count INT;
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
SELECT COUNT(*) INTO v_count
FROM groups
WHERE groups.name = :new.name;

IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Group name must be unique');
END IF;
END;
/

--3
CREATE OR REPLACE TRIGGER trigger_delete_group_fk
    AFTER DELETE ON groups
    FOR EACH ROW
BEGIN
DELETE FROM students WHERE group_id = :old.id;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in trigger_delete_group_fk: ' || SQLERRM);
END;
/

CREATE OR REPLACE TRIGGER trigger_insert_student_fk
    BEFORE INSERT ON students
    FOR EACH ROW
DECLARE
v_count INT;
BEGIN
SELECT COUNT(*) INTO v_count
FROM groups
WHERE groups.id = :new.group_id;

IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20000, 'Group ID does not exist');
END IF;
END;
/

--4
CREATE OR REPLACE TRIGGER trigger_students_logging
    AFTER INSERT OR UPDATE OR DELETE ON students
    FOR EACH ROW
DECLARE
v_username VARCHAR2(30) := USER;
    v_date DATE := SYSDATE;
    v_operation VARCHAR2(20);
BEGIN
    IF INSERTING THEN
        v_operation := 'INSERT';
INSERT INTO students_log (username, date_of_action, operation, stud_id, stud_name, stud_group_id)
VALUES (v_username, v_date, v_operation, :new.id, :new.name, :new.group_id);
ELSIF UPDATING THEN
        v_operation := 'UPDATE';
INSERT INTO students_log (username, date_of_action, operation, stud_id, stud_name, stud_group_id)
VALUES (v_username, v_date, v_operation, :new.id, :new.name, :new.group_id);
ELSIF DELETING THEN
        v_operation := 'DELETE';
INSERT INTO students_log (username, date_of_action, operation, stud_id, stud_name, stud_group_id)
VALUES (v_username, v_date, v_operation, :old.id, :old.name, :old.group_id);
END IF;
END;
/

--5
CREATE OR REPLACE PROCEDURE restore_students_info (date_time IN TIMESTAMP, time_offset IN INTERVAL DAY TO SECOND)
AS
    cur_date TIMESTAMP := SYSTIMESTAMP - time_offset;
BEGIN
DELETE FROM students;

FOR student IN (
        SELECT *
        FROM students_log
        WHERE date_of_action <= date_time + time_offset
        ORDER BY date_of_action ASC
        ) LOOP
            IF student.operation = 'INSERT' THEN
                INSERT INTO students (id, name, group_id)
                VALUES (student.stud_id, student.stud_name, student.stud_group_id);
COMMIT;
ELSIF student.operation = 'UPDATE' THEN
UPDATE students
SET name = student.stud_name, group_id = student.stud_group_id
WHERE id = student.stud_id;
COMMIT;
ELSIF student.operation = 'DELETE' THEN
DELETE FROM students
WHERE id = student.stud_id;
COMMIT;
END IF;
END LOOP;

DELETE FROM students_log WHERE date_of_action >= cur_date;
END;
/
--6
CREATE OR REPLACE TRIGGER trigger_group_c_val_students_update
    AFTER UPDATE ON students
                     FOR EACH ROW
BEGIN
    IF (:old.group_id != :new.group_id) THEN
UPDATE groups SET c_val = c_val - 1 WHERE id = :old.group_id;
UPDATE groups SET c_val = c_val + 1 WHERE id = :new.group_id;
END IF;
END;
/

CREATE OR REPLACE TRIGGER trigger_group_c_val_students_insert
    AFTER INSERT ON students
    FOR EACH ROW
BEGIN
UPDATE groups SET c_val = c_val + 1 WHERE id = :new.group_id;
END;
/

CREATE OR REPLACE TRIGGER trigger_group_c_val_students_delete
    BEFORE DELETE ON students
    FOR EACH ROW
BEGIN
UPDATE groups SET c_val = c_val - 1 WHERE id = :old.group_id;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in trigger_group_c_val_students_delete: ' || SQLERRM);
END;
/

--                                                            Lab2
DELETE FROM students;
DELETE FROM groups;
--DELETE FROM students_log;
COMMIT;

INSERT INTO groups (name, c_val) VALUES ('153501', 0);
INSERT INTO groups (name, c_val) VALUES ('153502', 0);
INSERT INTO groups (name, c_val) VALUES ('153503', 0);
INSERT INTO groups (name, c_val) VALUES ('153504', 0);
COMMIT;

INSERT INTO students (name, group_id) VALUES ('Pavel', 1);
INSERT INTO students (name, group_id) VALUES ('Ilya', 2);
INSERT INTO students (name, group_id) VALUES ('Kolya', 3);
INSERT INTO students (name, group_id) VALUES ('Anton',2);
INSERT INTO students (name, group_id) VALUES ('Vlad', 4);
COMMIT;

SELECT * FROM students;
SELECT * FROM groups;
SELECT * FROM students_log;

CALL restore_students_info_by_date(TO_TIMESTAMP('2024-02-24 00:24:28', 'YYYY-MM-DD HH24:MI:SS'));
COMMIT;

INSERT INTO groups VALUES (5, '153505', 0);
COMMIT;

DELETE FROM groups WHERE id = 2;
COMMIT;


DELETE FROM students WHERE name LIKE '%PP%';
COMMIT;


INSERT INTO groups VALUES (8, '153502', 0);
COMMIT;
INSERT INTO groups VALUES (9, '153502', 0);
COMMIT;

--Testing the trigger trigger_students_unique_id (preventing duplicate student IDs):
INSERT INTO students (id, name, group_id) VALUES (126, 'John', 1);
-- This should raise an error: "ID must be unique"

--Testing the trigger trigger_groups_unique_name (ensuring unique group names):
INSERT INTO groups (id, name, c_val) VALUES (5, '153503', 0);
-- This should raise an error: "Group name must be unique"

--Testing the trigger trigger_delete_group_fk (deleting associated students when a group is deleted):
DELETE FROM groups WHERE id = 27;
SELECT * FROM students;
COMMIT;

--Testing the trigger trigger_insert_student_fk (ensuring a valid group ID is inserted):
INSERT INTO students (id, name, group_id) VALUES (6, 'В', 10);
-- This should raise an error: "Group ID does not exist"

--Testing the trigger trigger_students_logging (logging student operations):
INSERT INTO students (id, name, group_id) VALUES (6, 'Ф', 1);
SELECT * FROM students_log;

--Testing the stored procedure restore_students_info_by_date:
DECLARE
v_date_time TIMESTAMP := TO_TIMESTAMP('2024-02-24 00:25:28', 'YYYY-MM-DD HH24:MI:SS');
    v_time_offset INTERVAL DAY TO SECOND := INTERVAL '0' HOUR;
BEGIN
    restore_students_info(v_date_time, v_time_offset);
COMMIT;
DBMS_OUTPUT.PUT_LINE('Информация восстановлена успешно.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Произошла ошибка при восстановлении информации: ' || SQLERRM);
END;
/

--Testing the triggers trigger_group_c_val_students_update, trigger_group_c_val_students_insert, and trigger_group_c_val_students_delete (updating the c_val column in groups table):
-- Update a student's group_id and check the c_val column in groups table
UPDATE students SET group_id = 27 WHERE id = 131;
SELECT * FROM groups;
COMMIT;

-- Insert a new student and check the c_val column in groups table
INSERT INTO students (id, name, group_id) VALUES (7, 'Michael', 29);
SELECT * FROM groups;
COMMIT;

-- Delete a student and check the c_val column in groups table
DELETE FROM students WHERE id = 136;
SELECT * FROM groups;
COMMIT;
